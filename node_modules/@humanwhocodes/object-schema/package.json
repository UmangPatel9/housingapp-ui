{
  "_args": [
    [
      {
        "raw": "@humanwhocodes/object-schema@^1.2.0",
        "scope": "@humanwhocodes",
        "escapedName": "@humanwhocodes%2fobject-schema",
        "name": "@humanwhocodes/object-schema",
        "rawSpec": "^1.2.0",
        "spec": ">=1.2.0 <2.0.0",
        "type": "range"
      },
      "G:\\Umang\\Housing app\\react app\\housingapp-ui\\node_modules\\@humanwhocodes\\config-array"
    ]
  ],
  "_from": "@humanwhocodes/object-schema@^1.2.0",
  "_hasShrinkwrap": false,
  "_id": "@humanwhocodes/object-schema@1.2.0",
  "_location": "/@humanwhocodes/object-schema",
  "_nodeVersion": "14.15.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/object-schema_1.2.0_1616205711548_0.5436041366332698"
  },
  "_npmUser": {
    "name": "nzakas",
    "email": "nicholas@nczconsulting.com"
  },
  "_npmVersion": "6.14.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@humanwhocodes/object-schema@^1.2.0",
    "scope": "@humanwhocodes",
    "escapedName": "@humanwhocodes%2fobject-schema",
    "name": "@humanwhocodes/object-schema",
    "rawSpec": "^1.2.0",
    "spec": ">=1.2.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@humanwhocodes/config-array"
  ],
  "_resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.0.tgz",
  "_shasum": "87de7af9c231826fdd68ac7258f77c429e0e5fcf",
  "_shrinkwrap": null,
  "_spec": "@humanwhocodes/object-schema@^1.2.0",
  "_where": "G:\\Umang\\Housing app\\react app\\housingapp-ui\\node_modules\\@humanwhocodes\\config-array",
  "author": {
    "name": "Nicholas C. Zakas"
  },
  "bugs": {
    "url": "https://github.com/humanwhocodes/object-schema/issues"
  },
  "dependencies": {},
  "description": "An object schema merger/validator",
  "devDependencies": {
    "chai": "^4.2.0",
    "eslint": "^5.13.0",
    "mocha": "^5.2.0"
  },
  "directories": {
    "test": "tests"
  },
  "dist": {
    "integrity": "sha512-wdppn25U8z/2yiaT6YGquE6X8sSv7hNMWSXYSSU1jGv/yd6XqjXgTDJ8KP4NgjTXfJ3GbRjeeb8RTV7a/VpM+w==",
    "shasum": "87de7af9c231826fdd68ac7258f77c429e0e5fcf",
    "tarball": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.0.tgz",
    "fileCount": 12,
    "unpackedSize": 44591,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgVVeQCRA9TVsSAnZWagAANSgP/2euzfJPf1oyYNoWK/QP\nKaKV/7eTjiunTaq1E2yg4fuiYoa44xen2FVvKsflNJwablO0ol7899UKlnaN\nd3q8wzhf4BVJj/zFoWC/jHA/Q3Xn+gFySmM9ic2hVnciw7HxST1RtSB1YFtA\n2dzPE9/Peswbezja/0dYRlfa5PgJGML8FW+J01w1NtMSSQmafq8k4RxiYUQa\nbnOq2RtHsdQ2IOXsbfCWjb2OiOyOAkdsKMKlCaI/e5xc6VaG6EU6hnJw+dWQ\n9QQccQLe7lVuCBAOUyBGmQwSNAl9xvCrCEyzFTJvG0u28yjKXYjq5Ue4G5CM\n3Ue/vA0lKleHt8uAiZ1RceZGGITEYM42uIOr/8pfsnkB0Wq3kTc+byw/5lbw\nhrimZ1JHqh+Qej9sVcAnIUEeDsW7t0TB0m7+q0IfWRBl9OsCt09LCB21H3Mf\nVm458MhwccX5TQlEG1QW97DrENsYofCzb+JKVDGVRBPD6Mr2pZG7PUVuHIUm\nbBlpN+W/NC/ModuPs25Z9odJvzabAKpniAzuwyxWraKdGp93cTsRlulTsaUh\ngjsRPqJMycrTUSgrEY+5chQ14flBRxmqhfe+8zu5gT858JWcWn3TNEcAlTrt\n8u5JWT08apJXrVwl2mZ3Gp8PatDXv1B6HHeuVCDjKkInR8mk2I3CwFd7UQkR\nkVKg\r\n=Iepv\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "e053c89308b982af4fc654ae68035240830a5b8b",
  "homepage": "https://github.com/humanwhocodes/object-schema#readme",
  "keywords": [
    "object",
    "validation",
    "schema",
    "merge"
  ],
  "license": "BSD-3-Clause",
  "main": "src/index.js",
  "maintainers": [
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "name": "@humanwhocodes/object-schema",
  "optionalDependencies": {},
  "readme": "# JavaScript ObjectSchema Package\n\nby [Nicholas C. Zakas](https://humanwhocodes.com)\n\nIf you find this useful, please consider supporting my work with a [donation](https://humanwhocodes.com/donate).\n\n## Overview\n\nA JavaScript object merge/validation utility where you can define a different merge and validation strategy for each key. This is helpful when you need to validate complex data structures and then merge them in a way that is more complex than `Object.assign()`.\n\n## Installation\n\nYou can install using either npm:\n\n```\nnpm install @humanwhocodes/object-schema\n```\n\nOr Yarn:\n\n```\nyarn add @humanwhocodes/object-schema\n```\n\n## Usage\n\nUse CommonJS to get access to the `ObjectSchema` constructor:\n\n```js\nconst { ObjectSchema } = require(\"@humanwhocodes/object-schema\");\n\nconst schema = new ObjectSchema({\n\n    // define a definition for the \"downloads\" key\n    downloads: {\n        required: true,\n        merge(value1, value2) {\n            return value1 + value2;\n        },\n        validate(value) {\n            if (typeof value !== \"number\") {\n                throw new Error(\"Expected downloads to be a number.\");\n            }\n        }\n    },\n\n    // define a strategy for the \"versions\" key\n    version: {\n        required: true,\n        merge(value1, value2) {\n            return value1.concat(value2);\n        },\n        validate(value) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"Expected versions to be an array.\");\n            }\n        }\n    }\n});\n\nconst record1 = {\n    downloads: 25,\n    versions: [\n        \"v1.0.0\",\n        \"v1.1.0\",\n        \"v1.2.0\"\n    ]\n};\n\nconst record2 = {\n    downloads: 125,\n    versions: [\n        \"v2.0.0\",\n        \"v2.1.0\",\n        \"v3.0.0\"\n    ]\n};\n\n// make sure the records are valid\nschema.validate(record1);\nschema.validate(record2);\n\n// merge together (schema.merge() accepts any number of objects)\nconst result = schema.merge(record1, record2);\n\n// result looks like this:\n\nconst result = {\n    downloads: 75,\n    versions: [\n        \"v1.0.0\",\n        \"v1.1.0\",\n        \"v1.2.0\",\n        \"v2.0.0\",\n        \"v2.1.0\",\n        \"v3.0.0\"\n    ]\n};\n```\n\n## Tips and Tricks\n\n### Named merge strategies\n\nInstead of specifying a `merge()` method, you can specify one of the following strings to use a default merge strategy:\n\n* `\"assign\"` - use `Object.assign()` to merge the two values into one object.\n* `\"overwrite\"` - the second value always replaces the first.\n* `\"replace\"` - the second value replaces the first if the second is not `undefined`.\n\nFor example:\n\n```js\nconst schema = new ObjectSchema({\n    name: {\n        merge: \"replace\",\n        validate() {}\n    }\n});\n```\n\n### Named validation strategies\n\nInstead of specifying a `validate()` method, you can specify one of the following strings to use a default validation strategy:\n\n* `\"array\"` - value must be an array.\n* `\"boolean\"` - value must be a boolean.\n* `\"number\"` - value must be a number.\n* `\"object\"` - value must be an object.\n* `\"object?\"` - value must be an object or null.\n* `\"string\"` - value must be a string.\n* `\"string!\"` - value must be a non-empty string.\n\nFor example:\n\n```js\nconst schema = new ObjectSchema({\n    name: {\n        merge: \"replace\",\n        validate: \"string\"\n    }\n});\n```\n\n### Subschemas\n\nIf you are defining a key that is, itself, an object, you can simplify the process by using a subschema. Instead of defining `merge()` and `validate()`, assign a `schema` key that contains a schema definition, like this:\n\n```js\nconst schema = new ObjectSchema({\n    name: {\n        schema: {\n            first: {\n                merge: \"replace\",\n                validate: \"string\"\n            },\n            last: {\n                merge: \"replace\",\n                validate: \"string\"\n            }\n        }\n    }\n});\n\nschema.validate({\n    name: {\n        first: \"n\",\n        last: \"z\"\n    }\n});\n```\n\n### Remove Keys During Merge\n\nIf the merge strategy for a key returns `undefined`, then the key will not appear in the final object. For example:\n\n```js\nconst schema = new ObjectSchema({\n    date: {\n        merge() {\n            return undefined;\n        },\n        validate(value) {\n            Date.parse(value);  // throws an error when invalid\n        }\n    }\n});\n\nconst object1 = { date: \"5/5/2005\" };\nconst object2 = { date: \"6/6/2006\" };\n\nconst result = schema.merge(object1, object2);\n\nconsole.log(\"date\" in result);  // false\n```\n\n### Requiring Another Key Be Present\n\nIf you'd like the presence of one key to require the presence of another key, you can use the `requires` property to specify an array of other properties that any key requires. For example:\n\n```js\nconst schema = new ObjectSchema();\n\nconst schema = new ObjectSchema({\n    date: {\n        merge() {\n            return undefined;\n        },\n        validate(value) {\n            Date.parse(value);  // throws an error when invalid\n        }\n    },\n    time: {\n        requires: [\"date\"],\n        merge(first, second) {\n            return second;\n        },\n        validate(value) {\n            // ...\n        }\n    }\n});\n\n// throws error: Key \"time\" requires keys \"date\"\nschema.validate({\n    time: \"13:45\"\n});\n```\n\nIn this example, even though `date` is an optional key, it is required to be present whenever `time` is present.\n\n## License\n\nBSD 3-Clause\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/humanwhocodes/object-schema.git"
  },
  "scripts": {
    "test": "mocha tests/"
  },
  "version": "1.2.0"
}
